# 1 行目に整数 N, K が与えられます。
# 2 行目に N 個の文字列 s_1, s_2, ..., s_N が半角スペース区切りで与えられます。
# N 個の文字列を辞書順に並べ替え、K 番目の文字列を出力してください。

values = input().split()
N = int(values[0])
K = int(values[1])

S = [0] * N
values = input().split()
for i in range(N):
    S[i] = values[i]

sorted_S = sorted(S)

print(sorted_S[K - 1])

# 0 を N 個持つリストを反復を用いて用意して、半角スペースで分割された入力値を受け取ります。
# sorted 関数を使うことで、辞書順にソートできます。
# リストのインデックスは 0 から始まるので、K 番目の要素のインデックスは K-1 となります。

# 1 行目に整数 N が与えられます。
# N 番目までのフィボナッチ数を出力してください。

# フィボナッチ数は

# F_0 = 0
# F_1 = 1
# F_(n+2) = F_n + F_(n+1) (n は 0 以上)

# とし、F_0 を 1 番目とします。

N = int(input())

fibo = [0] * N
fibo[0] = 0
fibo[1] = 1

for i in range(2, N):
    fibo[i] = fibo[i - 2] + fibo[i - 1]

for ele in fibo:
    print(ele)


# 整数 N を受け取ります。
# N 番目のフィボナッチ数までループを用いて計算します。
# ループを用いて N 番目までのフィボナッチ数まで出力します。
# 説明の便宜上、N のフィボナッチ数を f(N) とします。
# フィボナッチ数は以下のようにルールが決まっています。
# N = 0 のとき、f(N) = 0
# N = 1 のとき、f(N) = 1
# N ≧ 2 のとき、f(N) = f(N-2) + f(N-1)
# これを今回はリストを用いて実現します。
# リストのインデックス i の要素に f(i) を格納して、この値を上位のフィボナッチ数を求める際に利用します。
# 【 詳しい流れ 】
# 【 入力 】
# 求められている出力は f(0) から f(N-1) までの計 N 個のフィボナッチ数の出力なので、リストの要素数が丁度 N になるように初期化します。それが fibo = [0] * N です。
# 【 フィボナッチ数 】
# まず、初項である f(0) = 0, f(1) = 1 を設定するために、fibo[0] = 0, fibo[1] = 1 を記述します。今回、リスト fibo は 0 で初期化されているので、fibo[0] = 0 は必ずしも記述する必要はありません。
# 後は、整数 i (2 ≦ i ≦ n-1) に対して、f(i) = f(i-2) + f(i-1) を行えばよいので、for 文を用いて fibo[i] = fibo[i-2] + fibo[i-1] を記述します。
# 最後に for 文を用いて出力します。


# 長さ N の数列Aが与えられます。Aの中に 0 が含まれていない場合はYESを、 0 が含まれている場合はNOを出力してください。

