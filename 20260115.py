# N 個の LED が付けられた電飾があります。 LED にはそれぞれ 1 から N までの番号が付けられており、
# 0 から 255 までの数値で明るさを調整することができます。 明るさ 0 は LED が消灯していることを意味します。

# LED は操作盤を使って、番号と明るさを指定して信号を送ることで操作することができます。
# 最初はすべての LED が消灯しています。 M 個の信号が与えられるので、N 個の LED が初めて同時に点灯したとき
# の明るさの合計を出力してください。
# 入力例 1 では電飾に LED が 4 つ付いており、信号は 7 つ送られます。 N 個の LED が初めて同時に点灯したのは
# 6 つ目の信号が送られたときで、そのときの LED の明るさの合計は 32 + 8 + 64 + 16 = 120 なので
# 120 と出力してください。
def solve():
    N,M = map(int, input().split())
    s = 0 #ループかLEDの管理に必要かと思ったけど、正直いらんかった
    l = [0]*N #LEDの個数を把握するやつ
    while s<M: #M回ループさせるよってやつやけどforでも良い
        a,b = map(int, input().split())
        s += 1 #ループ回数を増やしてるけど正直いらない
        l[a-1] = b #LEDの状態を更新する変数。pythonのインデックスに合わせるために−1してある
        if all(x > 0 for x in l):#さっきのlを参照にLEDの状態がN個っ全部点灯しているか確認し。
            print(sum(l)) #TRUEなら合計を出力する
            break
if __name__ == "__main__":
    solve()

# N, M = map(int,input().split())

# LED = [0] * N #明るさを管理する配列

# for i in range(M):
#     a, b = map(int,input().split())
#     LED[a - 1] = b
#     #すべてのランプが点灯→全てのランプの明るさが正ならば、総和を出力し繰り返し処理を止める
#     if min(LED) > 0:
#         print(sum(LED))
#         break


# 1 行目には 1 つの整数 N が与えられます。
# 2 行目には N 個の整数 A_1,A_2,...,A_N が与えられます。
# 入力は 2 行となり、末尾に改行が 1 つ入ります
# ・1 行目には、等差数列である場合は "Yes" を、そうでない場合は "No" を

# ・2 行目には、等比数列である場合は "Yes" を、そうでない場合は "No" を

N = int(input())

A = list(map(int,input().split()))

ans_arith = "Yes"

#隣接 2 項間の差分を求め、すべて等しければ Yes、そうでなければ No → 1 ≦ i ≦ N - 2 を満たす i で A_{i + 2} - A{i + 1} = A_{i + 1} - A_i が成り立てば Yes、そうでなければ No 
for i in range(N - 2):
    if A[i + 2] - A[i + 1] != A[i + 1] - A[i]:
        ans_arith = "No"

print(ans_arith)

ans_geo = "Yes"

#等比数列と同じように求める。誤差に注意し、A_{i + 2} × A_i = A_{i + 1} × A_{i + 1} で判定
for i in range(N - 2):
    if A[i + 2] * A[i] != A[i + 1] ** 2:
        ans_geo = "No"

print(ans_geo)

# 1 行目には社員の数を表す整数 N が与えられ、2 行目 〜 (N + 1) 行目の各行では、
# 社員の名前を表す文字列 s_i とその社員の昨年度の年齢を表す整数 a_i が半角スペース区切りで与えられます（1 ≤ i ≤ N）。
# coding: utf-8
# 自分の得意な言語で
# Let's チャレンジ！！
N = int(input())

for i in range(N):
    A,b = input().split()
    B = int(b)+1

    print("{} {}".format(A,B))


# まず、正整数 M が発表され、参加者は手元の紙に M 個、好きな数字を書きます。
# このとき、紙に書く数のそれぞれは 1 以上 M 以下であり、同じ数字を何度書いても構いません。
# その後、 1 以上 M 以下の数 K が発表され、各参加者は自分の紙に数字 K を書いた数だけポイントをもらい、
# ポイントの高い順に景品が配られます。
# 忘年会の参加者の人数 N と、数 M , K が与えられ、各参加者が書いた紙が与えられるので、
# それぞれの参加者の得点を計算して出力してください。
# 1 行目には上で説明した数 N, M, K が半角スペース区切りで与えられ、
# 2 行目から (N + 1) 行目までには各参加者が紙に書いた数字が M 個ずつ半角スペース区切りで、 N 回与えられます。
# coding: utf-8
# 自分の得意な言語で
# Let's チャレンジ！！
line = input().split()
N = int(line[0])
for i in range(N):
    M = int(line[1])
    K = line[2]
    a = input().split()
    b = a.count(K)
    print(b)

# 解答例はこっち
# N, M, K = map(int, input().split()) 1行目を分割して整数で受け取るやで

# for i in range(N):
#     a = [int(j) for j in input().split()] 2行目を分割して整数で受け取るやで
#     ans = 0 Kを数える変数やで
#     for j in range(M):
#         if a[j] == K: aの中からjを探す
#             ans += 1 あれば変数に１を足すやで
#     print(ans)


# N 人の人々がおり、それぞれの人は金と銀を何キログラムか持っています。今は金の方が銀よりも価値が高いですが、
# ある日金と銀の価値が逆転して、人々の財産の多さは次のように決定されるようになりました。
# 1. 持っている銀が多い方が財産が多い。
# 2. 持っている銀が同じなら、持っている金が多い方が財産が多い。
# 1 行目には人々の数を表す整数 N が与えられ、 2 行目から (N + 1) 行目には、
# 人々が持っている金の量 g_i と銀の量 s_i がそれぞれ半角スペース区切りで N 行与えられます （1 ≤ i ≤ N）。
# coding: utf-8
# 自分の得意な言語で
# Let's チャレンジ！！
N = int(input())
A = []
for _ in range(N):
    a,b = map(int, input().split())
    A.append((a,b))
B = sorted(A, key=lambda x: (-x[1], -x[0]))
for a, b in B:
    print(a, b)

# 解答例はこっち
# N = int(input())
# kingin = [0] * N 空のリスト作って

# for i in range(N): Nでループして
#     [a, b] = [int(j) for j in input().split()] 入力する。この辺まではおなじ
#     kingin[i] = [b, a] 空リストに順序逆で格納

# kingin.sort(reverse=True) 降順でソートする

# for i in range(N):
#     [a, b] = kingin[i]
#     print(b, a)

# p 人のグループ A , q 人のグループ B , r 人のグループ C があります。各グループのメンバーにはそれぞれ番号がつけられており、
# A グループの i 番目の人は B グループの j 番目の人に仕事を任せ、 B グループの j 番目の人は与えられた仕事を
# C グループの k 番目の人に任せます。すると結局、 A グループの i 番目の人の仕事をするのは C グループの k 番目の人だということになります。

# パイザ君は A グループの各人の仕事を結局 C グループの誰が行うことになるのか知りたがっています。
# A グループの人のそれぞれが最終的に C グループの誰に仕事を頼むことになるのかを、
# A グループの人の番号が小さい順に p 行出力してください。
# 入力
p, q, r = map(int, input().split())

# A → B の対応表
a_to_b = [0] * p
for _ in range(p):
    a, b = map(int, input().split())
    a_to_b[a-1] = b  # 0始まりに調整

# B → C の対応表
b_to_c = [0] * q
for _ in range(q):
    j, k = map(int, input().split())
    b_to_c[j-1] = k  # 0始まりに調整

# A の各人が最終的に C の誰に仕事を頼むか
for i in range(p):
    b = a_to_b[i]       # A[i] が頼む B の番号
    c = b_to_c[b-1]     # その B が頼む C の番号
    print(i+1, c)       # 出力は A の番号、C の番号

# [p, q, r] = [int(i) for i in input().split()]
# AB = {}
# BC = {}

# for _ in range(p): p人の範囲でループする
#     [i, j] = [int(n) for n in input().split()]
#     AB[i] = j A→Bをリストに入れる


# for _ in range(q): 上と同じ
#     [j, k] = [int(n) for n in input().split()]
#     BC[j] = k

# AC = {}


# for i in range(1, p + 1):
#     AC[i] = BC[AB[i]]

# for i, k in AC.items():
#     print(i, k)

# バトルはターン制で、パイザ君が先攻で、パイザ君とモンスターで交互に魔法を使い合います。
# パイザ君の魔法は 1 回目と 2 回目に使うときにはダメージ 1 ですが、 3 回目以降の n 回目には、
# (モンスターから受けた (n - 1) 回目の攻撃のダメージ) + (モンスターから受けた (n - 2) 回目の攻撃のダメージ) のダメージを与
# えます。モンスターの魔法はこれよりも強力で、 1 回目と 2 回目には同じくダメージ 1 ですが、 3 回目以降の n 回目には、
# (パイザ君から受けた (n - 1) 回目の攻撃のダメージ) * 2 + (パイザ君から受けた (n - 2) 回目の攻撃のダメージ) のダメージを
# 与えます。
# パイザ君は自分がどれくらいモンスターの攻撃を耐えられるか知りたいと思っています。パイザ君の体力を H として、
# 両者が同じ魔法を使い続けたとき、モンスターの何回目の攻撃でパイザ君の体力が 0 以下になるかを出力してください。
H = int(input())

# 先に初期化（1-indexed）
pa = [0, 1, 1]  # パイザ君攻撃ダメージ
mo = [0, 1, 1]  # モンスター攻撃ダメージ

turn = 2  # すでに2回攻撃済みと考える
while True:
    turn += 1 #ターンを増やす
    # パイザ君の攻撃
    pa.append(mo[turn-1] + mo[turn-2])
    # モンスターの攻撃
    mo_dmg = 2*pa[turn-1] + pa[turn-2]
    mo.append(mo_dmg)

    # H からモンスター攻撃を引く
    H -= mo_dmg

    if H <= 0:
        print(turn)  # この攻撃回で H <= 0
        break
# こっちだと処理がどんどん伸びて失敗する

# 解答例はこっち
# H = int(input()) 体力

# a = [0, 1, 1] ダメージの初期値
# b = [0, 1, 1]

# dmg = 2 累積ダメージ数

# i = 2 ターン数（攻撃回数）

# while dmg < H: ダメージが体力より低いなら
#     a[0] = a[1] それぞれのダメージを更新していく
#     a[1] = a[2]
#     b[0] = b[1]
#     b[1] = b[2]

#     a[2] = b[0] + b[1] 直近2回から計算されるダメージになる
#     b[2] = a[0] + 2 * a[1] ダメージのリストが伸びるんじゃなくて上書きされるから処理が軽い

#     dmg += b[2] 累積ダメージを更新する

#     i += 1 ターン数を増やす

# print(i)


# 工事が N 週間続くとして、各週日曜日の工事が始まる時刻と、工事が何時間何分続くのかに関する情報が与えられるので、
# 工事が終わる時刻を 00:00 から 23:59 までの 24 時間表記で出力してください（ここで「工事が終わる時刻」とは、工事が 
# h 時間 m 分続くとした場合、工事が始まった時刻の h 時間 m 分後を指します）。

# 1 行目には工事が続く週の数を表す正整数 N が与えられ、 2 行目から (N + 1) 行目には工事が始まる時刻と、
# 工事がどれくらい続くのかについての情報が、 "t_i h_i m_i" という形式で与えられます（1 ≤ i ≤ N）。
# これは時刻 t_i に工事が始まり、 h_i 時間 m_i 分工事が続くことを意味しています。
# t_i, h_i, m_i は各行において半角スペース区切りで与えられます。

# t_i は 24 時間表記で時刻を表す文字列で、 "AB:XY" という形をしており、これは AB 時 XY 分を表します。
# ただし、今回は 00:00 から 23:59 までの 24 時間表記を採用し、時・分を表す数字が 1 桁の場合には十の位を 0 で埋めます。
N = int(input())

for i in range(N):
    line = input().split()
    th,tm = map(int,line[0].split(":"))
    h = int(line[1])
    m = int(line[2]) #この辺まではいけたけど、１度24時間表記に直すとこでつまづいた
    T = th*60 + tm + h*60 + m
    T %= 24*60
    H = T // 60
    M = T % 60
    print("{:02d}:{:02d}".format(H,M)) #ここも最初は空白埋めにしてた


#解答例はこっち
# N = int(input())

# for i in range(N):
#     [t, h, m] = input().split()
#     th = int(t[:2])
#     tm = int(t[3:])
#     h = int(h)
#     m = int(m)

#     ah = th + h
#     am = tm + m

#     if am >= 60:
#         ah += 1
#         am -= 60
#     if ah >= 24:
#         ah -= 24

#     ah = str(ah)
#     am = str(am)

#     if len(ah) == 1:
#         ah = "0" + ah
#     if len(am) == 1:
#         am = "0" + am

#     print(ah + ":" + am)

#